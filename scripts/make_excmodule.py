#!/usr/bin/env python
"""Generate the exc.py module from the content of errorcodes.py

You may run this script after make_errorcodes.py has found some change.
"""

# Copyright (C) 2014 Daniele Varrazzo  <daniele.varrazzo@gmail.com>
#
# psycopg2 is free software: you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# psycopg2 is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
# License for more details.

import os
import sys
from operator import itemgetter

def main():
    if len(sys.argv) != 2:
        print >>sys.stderr, "usage: %s /path/to/exc.py" % sys.argv[0]
        return 2

    filename = sys.argv[1]

    parts = []
    parts.append(read_base_file(filename))

    module = import_errorcodes(filename)
    dc, de = read_codes(module)
    parts.append("\n# Exceptions representing PostgreSQL error classes\n")
    parts.extend(generate_classes(dc))
    parts.append("\n# Exceptions representing PostgreSQL errors\n")
    parts.extend(generate_exceptions(dc, de))

    with open(filename, "w") as f:
        f.write('\n'.join(parts))


def import_errorcodes(filename):
    """Return the module containing all the error codes definitions

    Use the errorcode version found in the same dir of the input file
    """
    sys.path.insert(0, os.path.abspath(os.path.dirname(filename)))
    import errorcodes
    sys.path.pop(0)
    return errorcodes

def read_codes(module):
    """Return dictionaries with the mappings of class and error codes to names

    Return (class_map, error_map)
    """
    dc, de = {}, {}
    for n in dir(module):
        v = getattr(module, n)
        if not isinstance(v, str):
            continue
        if n.startswith('CLASS_') and len(v) == 2:
            dc[n] = v
        elif len(v) == 5:
            de[n] = v

    return dc, de

def generate_classes(dc):
    dl = sorted(dc.items(), key=itemgetter(1,0))
    used = {}

    for n, c in dl:
        # generate only an exception per code and use all the names
        if c not in used:
            used[c] = n
            yield """\
class %s(psycopg2.Error):
    code = %r
""" % (cname(n), c)

        else:
            yield """\
%s = %s
""" % (cname(n), cname(used[c]))

def generate_exceptions(dc, de):
    yield """# TODO: fix the proper base exception\n"""
    de = sorted(de.items(), key=itemgetter(1,0))

    # map class code to name, the first defined wins
    rdc = {}
    for n, c in sorted(dc.items(), key=itemgetter(1,0)):
        if c not in rdc:
            rdc[c] = n

    used = {}

    for n, c in de:
        # generate only an exception per code and use all the names
        if c not in used:
            used[c] = n
            yield """\
class %s(psycopg2.Error, %s):
    code = %r
""" % (cname(n), cname(rdc[c[:2]]), c)

        else:
            yield """\
%s = %s
""" % (cname(n), cname(used[c]))

def cname(n):
    # name from ANGRY_CASE to CamelCase
    return ''.join(part.title() for part in n.split('_'))


def read_base_file(filename):
    rv = []
    for line in open(filename):
        rv.append(line)
        if line.startswith("# autogenerated"):
            return ''.join(rv)

    raise ValueError("can't find the separator. Is this the right file?")

if __name__ == '__main__':
    sys.exit(main())

